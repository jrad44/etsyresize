<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Update the page title to reflect the new brand name. -->
  <title>ResizedImage ‚Äì Marketplace Image Resizer</title>
  <!-- Cropper.js styles for the cropping overlay -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.css">
  <style>
    :root {
      --primary-bg: #7757ff;
      --primary-bg-light: #8163ff;
      --primary-fg: #ffffff;
      --card-border: #e0e0e0;
      --card-hover: #f5f4ff;
      --selected-border: #7b61ff;
      --process-bg: linear-gradient(90deg,#adafbd,#c2c3d0);
      --process-fg: #ffffff;
      --pro-bg: #f7a400;
      --pro-fg: #ffffff;
      --pro-hover: #f0a818;
      --text-color: #333333;
      --subtext-color: #666666;
    }

  /* --- Custom cropping interface styles --- */
  /* Container overlay dims */
  .dim-overlay {
    position: absolute;
    background: rgba(0, 0, 0, 0.5);
    pointer-events: none;
  }
  .crop-box {
    position: absolute;
    border: 2px solid var(--selected-border);
    box-sizing: border-box;
    background: transparent;
    cursor: move;
  }
  .crop-handle {
    position: absolute;
    width: 12px;
    height: 12px;
    background: var(--primary-bg);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    pointer-events: all;
  }
  .crop-handle.nw { left: 0; top: 0; cursor: nwse-resize; }
  .crop-handle.ne { left: 100%; top: 0; cursor: nesw-resize; }
  .crop-handle.sw { left: 0; top: 100%; cursor: nesw-resize; }
  .crop-handle.se { left: 100%; top: 100%; cursor: nwse-resize; }
  .crop-handle.n { left: 50%; top: 0; cursor: ns-resize; }
  .crop-handle.s { left: 50%; top: 100%; cursor: ns-resize; }
  .crop-handle.w { left: 0; top: 50%; cursor: ew-resize; }
  .crop-handle.e { left: 100%; top: 50%; cursor: ew-resize; }
  .rule-line {
    position: absolute;
    background: rgba(255, 255, 255, 0.6);
    pointer-events: none;
  }

    /* Dark theme overrides using CSS variables. When data-theme="dark" is set on
       the document element, these values will override the defaults above to
       switch the palette to a darker scheme. */
    [data-theme="dark"] {
      --primary-bg: #372f62;
      --primary-bg-light: #443a77;
      --primary-fg: #f7f7ff;
      --card-border: #444444;
      --card-hover: #3a3a5e;
      --selected-border: #8f7fff;
      --process-bg: linear-gradient(90deg,#3e3e54,#545471);
      --process-fg: #ffffff;
      --pro-bg: #b58a00;
      --pro-fg: #ffffff;
      --pro-hover: #c99900;
      --text-color: #e0e0e0;
      --subtext-color: #b0b0c0;
    }
    body {
      font-family: ui-sans-serif, system-ui, sans-serif;
      max-width: 960px;
      margin: 24px auto;
      padding: 0 16px;
      color: var(--text-color);
    }
    /* Hero / Drop zone */
    .drop {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 200px;
      margin: 24px 0;
      border-radius: 16px;
      background: var(--primary-bg);
      color: var(--primary-fg);
      cursor: pointer;
      transition: background 0.3s;
    }
    .drop.dragover {
      background: var(--primary-bg-light);
    }
    .drop svg {
      width: 40px;
      height: 40px;
      margin-bottom: 8px;
    }
    .drop p {
      margin: 0;
      font-size: 1.2rem;
    }
    .drop small {
      font-size: 0.8rem;
      opacity: 0.8;
    }
    /* Preset grid */
    .preset-section {
      margin-top: 32px;
    }
    .preset-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px,1fr));
      gap: 12px;
      margin-top: 12px;
    }
    .preset-card {
      border: 1px solid var(--card-border);
      border-radius: 12px;
      padding: 16px;
      background: #ffffff;
      cursor: pointer;
      transition: box-shadow 0.2s, border-color 0.2s;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      min-height: 100px;
    }
    .preset-card:hover {
      background: var(--card-hover);
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }
    .preset-card.selected {
      border-color: var(--selected-border);
      box-shadow: 0 0 0 2px var(--selected-border);
    }
    .preset-card .icon {
      font-size: 1.5rem;
      margin-bottom: 4px;
    }
    .preset-card .title {
      font-weight: bold;
      font-size: 1rem;
    }
    .preset-card .size,
    .preset-card .quality {
      font-size: 0.8rem;
      color: var(--subtext-color);
    }
    .preset-card .checkmark {
      position: absolute;
      top: 8px;
      right: 8px;
      font-size: 1.2rem;
      color: var(--selected-border);
      display: none;
    }
    .preset-card.selected .checkmark {
      display: block;
    }

        /* Navigation bar styling */
        .menu-bar {
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 8px 0;
          background: #ffffff;
          position: sticky;
          top: 0;
          z-index: 1000;
        }
        .menu-bar .logo a {
          font-size: 1.2rem;
          font-weight: bold;
        }
        .menu-items {
          display: flex;
          gap: 16px;
          list-style: none;
          margin: 0;
          padding: 0;
        }
        .menu-items li a {
          text-decoration: none;
          color: var(--text-color);
          font-size: 0.9rem;
          padding: 4px 8px;
        }
        .menu-items li a.active {
          border-bottom: 2px solid var(--primary-bg);
          color: var(--primary-bg);
        }
        .hamburger {
          display: none;
          background: none;
          border: none;
          font-size: 1.4rem;
          cursor: pointer;
          line-height: 1;
        }
        .pro-btn {
          background: var(--pro-bg);
          color: var(--pro-fg);
          border-radius: 8px;
          padding: 6px 12px;
          border: none;
          font-size: 0.9rem;
          cursor: pointer;
          white-space: nowrap;
        }
        .pro-btn:hover {
          background: var(--pro-hover);
        }
        @media (max-width: 640px) {
          .menu-items {
            display: none;
            flex-direction: column;
            gap: 8px;
            background: #ffffff;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            padding: 8px 0;
            border-top: 1px solid var(--card-border);
          }
          .menu-items.open {
            display: flex;
          }
          .hamburger {
            display: block;
          }
        }

        /* Style the social presets selectors to match card aesthetics */
        #platformSelect, #placementSelect {
          border: 1px solid var(--card-border);
          border-radius: 8px;
          padding: 4px 8px;
          font-size: 0.9rem;
          background: #fff;
          margin-left: 8px;
        }
    /* Options */
    .options {
      margin-top: 32px;
      border-top: 1px solid var(--card-border);
      padding-top: 16px;
    }
    .option-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }
    .option-row label {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 0.9rem;
    }
    .option-row .pro-badge {
      background: var(--pro-bg);
      color: var(--pro-fg);
      font-size: 0.7rem;
      padding: 2px 4px;
      border-radius: 4px;
      margin-left: 4px;
    }
    .option-row input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }
    /* Custom inputs container */
    #customInputs {
      margin-top: 12px;
    }
    #customInputs label {
      margin-right: 12px;
    }
    /* Buttons */
    .process-btn {
      width: 100%;
      margin-top: 24px;
      padding: 16px;
      border-radius: 12px;
      border: none;
      /* Default (disabled) state: neutral grey gradient */
      background: var(--process-bg);
      color: var(--process-fg);
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.2s;
    }
    .process-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    /* When ready to process, turn the button green to indicate action */
    .process-btn.ready {
      /* Use a vibrant green gradient when the button is active to
         clearly communicate that the image is ready to process and download. */
      background: linear-gradient(90deg, #0cd45d, #17ba64);
      color: #ffffff;
    }

    /* Crop button styling */
    .crop-btn {
      width: 100%;
      margin-top: 12px;
      padding: 12px;
      border-radius: 12px;
      border: none;
      background: linear-gradient(90deg, #7b61ff, #9a7aff);
      color: #ffffff;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.2s;
    }
    .crop-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* Crop modal overlay */
    #cropModal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      z-index: 9999;
      align-items: center;
      justify-content: center;
    }
    #cropModal.open {
      display: flex;
    }
    #cropModal .modal-content {
      background: var(--primary-fg);
      color: var(--text-color);
      padding: 16px;
      border-radius: 12px;
      max-width: 95%;
      max-height: 95%;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    #cropPreviewArea {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      position: relative;
    }
    #cropControls {
      margin-top: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    #cropControls label {
      font-size: 0.85rem;
      display: flex;
      flex-direction: column;
    }
    #cropControls input[type="number"],
    #cropControls select {
      padding: 4px;
      border: 1px solid var(--card-border);
      border-radius: 6px;
      width: 80px;
    }
    #cropActions {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }
    #cropActions button {
      padding: 8px 12px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
    }
    #cropConfirmBtn {
      background: linear-gradient(90deg, #0cd45d, #17ba64);
      color: #ffffff;
    }
    #cropResetBtn, #cropCancelBtn {
      background: var(--card-hover);
      color: var(--text-color);
    }
    .pro-bar {
      width: 100%;
      margin-top: 16px;
      padding: 16px;
      border-radius: 12px;
      border: none;
      background: var(--pro-bg);
      color: var(--pro-fg);
      font-size: 0.95rem;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .pro-bar:hover {
      background: var(--pro-hover);
    }
    .pro-bar .features {
      font-size: 0.8rem;
      font-weight: normal;
    }
    /* Hide the original select; we'll still use it internally */
    #preset {
      display: none;
    }
    /* Hide original status list for now; we will display status near button */
    #list {
      margin-top: 8px;
      list-style: none;
      padding-left: 0;
      font-size: 0.85rem;
      color: var(--subtext-color);
    }
    #status {
      display: block;
      margin-top: 8px;
      font-size: 0.85rem;
      color: var(--subtext-color);
    }
    .hidden { display: none; }

    /* Modal overlay for prompting users to unlock pro features. The modal
       appears centered on screen with a dark translucent backdrop. */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    /* Ensure that the modal stays hidden when the hidden class is present.
       This override prevents other styles (like the flex display on .modal)
       from causing it to show inadvertently on page load. */
    .modal.hidden {
      display: none !important;
    }
    .modal-content {
      background: #fff;
      padding: 24px;
      border-radius: 12px;
      max-width: 440px;
      text-align: center;
      color: #333;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .modal-content p {
      margin-bottom: 16px;
      font-size: 0.95rem;
      line-height: 1.4;
    }
    .modal-content a.stripe-link {
      display: inline-block;
      margin-top: 8px;
      padding: 10px 16px;
      border-radius: 8px;
      background: var(--pro-bg);
      color: var(--pro-fg);
      text-decoration: none;
      font-weight: bold;
    }
    .modal-content a.stripe-link:hover {
      background: var(--pro-hover);
    }
    .modal-content button.close-btn {
      margin-top: 12px;
      padding: 8px 14px;
      border: none;
      border-radius: 6px;
      background: #e0e0e0;
      cursor: pointer;
      font-size: 0.85rem;
    }
    .modal-content button.close-btn:hover {
      background: #d0d0d0;
    }

    /* Styling for the unlocked indicator shown next to the watermark option
       when the paid tier is active */
    .unlocked-note {
      margin-left: 6px;
      font-size: 0.75rem;
      font-weight: bold;
      color: #12c271;
    }

    /* Theme toggle container in top-right corner */
    .theme-toggle {
      position: absolute;
      top: 16px;
      right: 16px;
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 0.9rem;
      color: var(--primary-fg);
      cursor: pointer;
    }
    .theme-toggle input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }
  </style>
</head>
    <body>
    <!-- Global Navigation Bar -->
    <nav id="menuBar" class="menu-bar" role="navigation">
      <div class="logo">
        <a href="/" style="text-decoration:none;font-weight:bold;font-size:1.2rem;color:var(--text-color);">ResizedImage</a>
      </div>
      <button id="hamburger" class="hamburger" aria-label="Toggle navigation">‚ò∞</button>
      <ul id="menuItems" class="menu-items">
        <li><a href="/" id="navResizer">Image Resizer</a></li>
        <li><a href="/pdf" id="navPdf">PDF Tool</a></li>
        <li><a href="/background" id="navBg">Background Remover</a></li>
      </ul>
      <button id="navProBtn" class="pro-btn">Unlock&nbsp;Pro&nbsp;($2)</button>
    </nav>
  <!-- Update the main heading and description for the new brand name. -->
  <h1>ResizedImage ‚Äì Marketplace Image Resizer</h1>
  <p>Instantly resize your product photos to fit popular marketplaces like Amazon, Etsy, Shopify and more. No signup required. The free version allows one image up to 10‚ÄØMB. Unlock batch resizing and larger file limits for a small one‚Äëtime fee.</p>

  <!-- Theme toggle; allows switching between light and dark mode. This control is positioned
       at the top‚Äëright of the page via CSS. The associated script persists the user's
       preference in localStorage and applies the dark theme automatically on load. -->
  <div class="theme-toggle">
    <label for="themeToggle">Dark mode</label>
    <input type="checkbox" id="themeToggle">
  </div>

  <!-- Hero drop zone -->
  <div id="drop" class="drop">
    <!-- upload icon -->
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M4 17v1a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-1"/>
      <polyline points="12 12 12 3 16 7"/>
      <polyline points="8 7 12 3 16 7"/>
    </svg>
    <p>Tap or drag images here</p>
    <small>Free: 1 image at a time</small>
    <input id="file" type="file" accept="image/*" multiple hidden>
  </div>

  <!-- Hidden preset select for internal use -->
  <select id="preset">
    <option value='{"w":2000,"h":2000,"fmt":"jpeg","q":0.82,"name":"Amazon"}'>Amazon</option>
    <option value='{"w":2700,"h":2025,"fmt":"jpeg","q":0.85,"name":"Etsy"}'>Etsy</option>
    <option value='{"w":2048,"h":2048,"fmt":"jpeg","q":0.9,"name":"Shopify"}'>Shopify</option>
    <option value='{"w":1600,"h":1600,"fmt":"jpeg","q":0.8,"name":"eBay"}'>eBay</option>
    <option value='{"w":0,"h":0,"fmt":"jpeg","q":0.9,"name":"Custom"}'>Custom</option>
    <option value='{"w":2000,"h":2000,"fmt":"jpeg","q":0.85,"name":"Poshmark"}'>Poshmark</option>
    <option value='{"w":1080,"h":1080,"fmt":"jpeg","q":0.8,"name":"Mercari"}'>Mercari</option>
  </select>

  <!-- Marketplace presets (static). You can remove or modify these if not needed. -->
  <div class="preset-section">
    <h2>Marketplace Presets</h2>
    <div class="preset-grid" id="marketplaceGrid">
      <!-- Existing marketplace presets defined via data-value for backward compatibility -->
      <div class="preset-card" data-value='{"w":2000,"h":2000,"fmt":"jpeg","q":0.82,"name":"Amazon"}'>
        <div class="icon">üõí</div>
        <div class="title">Amazon</div>
        <div class="size">2000 √ó 2000</div>
        <div class="quality">JPEG ‚Ä¢ 82%</div>
        <div class="checkmark">‚úî</div>
      </div>
      <div class="preset-card" data-value='{"w":2700,"h":2025,"fmt":"jpeg","q":0.85,"name":"Etsy"}'>
        <div class="icon">üè¨</div>
        <div class="title">Etsy</div>
        <div class="size">2700 √ó 2025</div>
        <div class="quality">JPEG ‚Ä¢ 85%</div>
        <div class="checkmark">‚úî</div>
      </div>
      <div class="preset-card" data-value='{"w":2048,"h":2048,"fmt":"jpeg","q":0.9,"name":"Shopify"}'>
        <div class="icon">üõçÔ∏è</div>
        <div class="title">Shopify</div>
        <div class="size">2048 √ó 2048</div>
        <div class="quality">JPEG ‚Ä¢ 90%</div>
        <div class="checkmark">‚úî</div>
      </div>
      <div class="preset-card" data-value='{"w":1600,"h":1600,"fmt":"jpeg","q":0.8,"name":"eBay"}'>
        <div class="icon">üì¶</div>
        <div class="title">eBay</div>
        <div class="size">1600 √ó 1600</div>
        <div class="quality">JPEG ‚Ä¢ 80%</div>
        <div class="checkmark">‚úî</div>
          </div>
        </div>
        <!-- Info about the selected marketplace preset (width √ó height and aspect ratio) -->
        <div id="marketPresetInfo" style="margin-top:8px;font-size:0.9rem;color:var(--subtext-color);"></div>
  </div>

  <!-- Social media presets loaded dynamically from social-image-presets-2025.json -->
  <div class="preset-section">
    <h2>Social Media Presets</h2>
    <label for="platformSelect">Platform:</label>
    <select id="platformSelect" style="margin-left:8px;"></select>
        <div id="socialPresetGrid" class="preset-grid"></div>
        <!-- Display selected social preset details -->
        <div id="socialPresetInfo" style="margin-top:8px;font-size:0.9rem;color:var(--subtext-color);"></div>
  </div>

  <!-- Options -->
  <div class="options">
    <h2>Options</h2>
    <div class="option-row hidden">
      <label for="keepAspect">Fit inside (no crop)</label>
      <input id="keepAspect" type="checkbox" checked>
    </div>
    <div class="option-row">
      <!-- Update label text to clarify that the toggle removes the watermark. When
           the site is unlocked this box becomes unchecked and disabled.
           An extra span with id="unlockedIndicator" will display a confirmation
           message when the pro tier is active. -->
      <label for="watermark">
        <!-- Watermark toggle removed -->
      </label>
      <!-- Watermark toggle removed -->
      <!-- <input id="watermark" type="checkbox"> -->
    </div>
    <div id="customInputs" class="hidden">
      <label>Width <input id="customW" type="number" min="1" step="1" style="width:80px;"></label>
      <label>Height <input id="customH" type="number" min="1" step="1" style="width:80px;"></label>
      <label>Format
        <select id="customFmt">
          <option value="jpeg">JPEG</option>
          <option value="png">PNG</option>
        </select>
      </label>
    <label>Quality
      <input id="customQ" type="range" min="50" max="100" value="90" style="width:120px;">
    </label>
    <span id="qualityValue" style="margin-left:4px;font-size:0.85rem;">90%</span>
    </div>
  </div>

  <!-- Status and file list -->
  <ul id="list"></ul>
  <small id="status"></small>

  <!-- Action buttons -->
  <button id="processBtn" class="process-btn" disabled>Process &amp; Download</button>
  <!-- New crop button: allows users to crop the currently selected image before resizing -->
  <button id="cropBtn" class="crop-btn" disabled>Crop Image</button>
  <button id="buyBtn" class="pro-bar">
    <span>Unlock Pro Features</span>
    <span class="features">Batch processing ‚Ä¢ Up to 50 files ‚Ä¢ $2.00</span>
  </button>

  <!-- Modal prompting users to upgrade to Pro when they attempt to remove the
       watermark on the free tier. This overlay appears above the page and
       prevents interaction until dismissed. The "Pay $2 via Stripe" link
       opens your Stripe checkout page in a new tab. -->
  <!-- Modal updated: now describes Pro features instead of watermark removal -->
  <div id="proModal" class="modal hidden" style="display:none;">
    <div class="modal-content">
      <p>Unlock batch processing and larger file limits with a small one‚Äëtime payment of $2. All future Pro features are included.</p>
      <a href="https://buy.stripe.com/test_cNi00bbCe5e1dKBdeh5os00" class="stripe-link" target="_blank">Pay¬†$2 via Stripe</a>
      <button id="closeModal" class="close-btn">Close</button>
    </div>
  </div>

  <!-- AdSense top banner -->
  <ins class="adsbygoogle"
       style="display:block; text-align:center; margin:12px 0;"
       data-ad-client="ca-pub-XXXX"
       data-ad-slot="9999999999"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <!-- AdSense bottom banner -->
  <ins class="adsbygoogle"
       style="display:block; text-align:center; margin:12px 0;"
       data-ad-client="ca-pub-XXXX"
       data-ad-slot="8888888888"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>

  <!-- Google AdSense: asynchronous load of the ad library. -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4695148041573402" crossorigin="anonymous"></script>
  <script>
  // Google AdSense loader
  (adsbygoogle = window.adsbygoogle || []).push({});
  (adsbygoogle = window.adsbygoogle || []).push({});

  const fileInput = document.getElementById('file');
  const drop = document.getElementById('drop');
  const list = document.getElementById('list');
  const statusEl = document.getElementById('status');
  const buyBtn = document.getElementById('buyBtn');
  const presetSelect = document.getElementById('preset');
  const customInputs = document.getElementById('customInputs');
  const customW = document.getElementById('customW');
  const customH = document.getElementById('customH');
  const customFmt = document.getElementById('customFmt');
      const customQ = document.getElementById('customQ');
      const qualityValue = document.getElementById('qualityValue');

      // Theme toggle: load stored preference and set up listener
      const themeToggleEl = document.getElementById('themeToggle');
      if (themeToggleEl) {
        // Apply saved theme on load
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
          document.documentElement.setAttribute('data-theme', 'dark');
          themeToggleEl.checked = true;
        }
        themeToggleEl.addEventListener('change', () => {
          if (themeToggleEl.checked) {
            document.documentElement.setAttribute('data-theme', 'dark');
            localStorage.setItem('theme', 'dark');
          } else {
            document.documentElement.removeAttribute('data-theme');
            localStorage.removeItem('theme');
          }
        });
      }
  // Declare files as a global variable so it can be accessed by other scripts (e.g., cropper)
  var files = [];

  // Check if unlocked via token in URL or localStorage
  const urlParams = new URLSearchParams(window.location.search);
  const urlToken = urlParams.get('token');
  if (urlToken) {
    localStorage.setItem('unlockToken', urlToken);
    const newParams = new URLSearchParams(window.location.search);
    newParams.delete('token');
    history.replaceState({}, '', `${location.pathname}${newParams.toString() ? '?' + newParams.toString() : ''}`);
  }
  const savedToken = localStorage.getItem('unlockToken');
  if (savedToken) {
    // verify token
    fetch('/unlock?token=' + encodeURIComponent(savedToken)).then(r => r.json()).then(j => {
      if (j.ok) {
        // Hide the watermark checkbox and show unlocked status when the paid tier is active
        const wmInput = document.getElementById('watermark');
        if (wmInput) {
          wmInput.checked = false;
          wmInput.disabled = true;
        }
        buyBtn.classList.add('hidden');
        const unlockedIndicator = document.getElementById('unlockedIndicator');
        if (unlockedIndicator) unlockedIndicator.classList.remove('hidden');
      } else {
        localStorage.removeItem('unlockToken');
        const unlockedIndicator = document.getElementById('unlockedIndicator');
        if (unlockedIndicator) unlockedIndicator.classList.add('hidden');
      }
    });
  }

  // Show or hide custom size inputs depending on selected preset
  function updateCustomVisibility() {
    try {
      const p = JSON.parse(presetSelect.value);
      if (p && p.name === 'Custom') {
        customInputs.classList.remove('hidden');
      } else {
        customInputs.classList.add('hidden');
      }
    } catch (e) {
      customInputs.classList.add('hidden');
    }
  }
  presetSelect.addEventListener('change', updateCustomVisibility);
  // Initialize visibility on page load
  updateCustomVisibility();

  // When user selects files via file input
  fileInput.addEventListener('change', e => {
    files = [...e.target.files];
    renderList();
  });
  // Make the entire drop zone clickable to open file chooser
  drop.addEventListener('click', () => {
    fileInput.click();
  });
  // Drag events: toggle a class for visual feedback
  drop.addEventListener('dragover', e => {
    e.preventDefault();
    drop.classList.add('dragover');
  });
  drop.addEventListener('dragleave', () => {
    drop.classList.remove('dragover');
  });
  drop.addEventListener('drop', e => {
    e.preventDefault();
    drop.classList.remove('dragover');
    files = [...e.dataTransfer.files];
    renderList();
  });

// Expose renderList on window so other scripts (cropping) can call it
window.renderList = function renderList() {
    list.innerHTML = '';
    files.forEach(f => {
      const li = document.createElement('li');
      li.textContent = `${f.name} (${(f.size/1024).toFixed(0)} KB)`;
      list.appendChild(li);
    });
    statusEl.textContent = files.length ? `${files.length} file(s) ready` : '';
    // Enable or disable the process button based on file selection
    const processBtnEl = document.getElementById('processBtn');
    if (processBtnEl) {
      const ready = files.length > 0;
      // When ready, remove the disabled attribute entirely so CSS rules
      // for the .ready state take effect. Otherwise, set the attribute.
      if (ready) {
        processBtnEl.removeAttribute('disabled');
      } else {
        processBtnEl.setAttribute('disabled', '');
      }
      // Toggle the ready class to control the green gradient styling
      processBtnEl.classList.toggle('ready', ready);
    }

    // Enable or disable the crop button. Crop only works for a single file at a time.
    const cropBtnEl = document.getElementById('cropBtn');
    if (cropBtnEl) {
      if (files.length === 1) {
        cropBtnEl.removeAttribute('disabled');
      } else {
        cropBtnEl.setAttribute('disabled', '');
      }
    }
  }

  document.getElementById('processBtn').onclick = async () => {
    if (!files.length) {
      alert('Add images first');
      return;
    }
    let preset;
    try {
      preset = JSON.parse(presetSelect.value);
    } catch (e) {
      preset = { w: 0, h: 0, fmt: 'jpeg', q: 0.9, name: 'Custom' };
    }
    // Override preset with a selected social preset if one is chosen
    const socialValEl = document.getElementById('selectedSocialPreset');
    if (socialValEl && socialValEl.value) {
      try {
        const sp = JSON.parse(socialValEl.value);
        preset = sp;
      } catch (e) {
        // ignore parse errors
      }
    }
    // If custom, override with user-provided values
        if (preset.name === 'Custom') {
          const wVal = parseInt(customW.value, 10);
          const hVal = parseInt(customH.value, 10);
          preset.w = isNaN(wVal) || wVal <= 0 ? 0 : wVal;
          preset.h = isNaN(hVal) || hVal <= 0 ? 0 : hVal;
          preset.fmt = customFmt.value || 'jpeg';
          // Convert quality slider (50-100) to decimal (0.5-1.0)
          const qVal = parseInt(customQ && customQ.value ? customQ.value : '90', 10);
          preset.q = isNaN(qVal) ? 0.9 : qVal / 100;
        }
    const keep = document.getElementById('keepAspect').checked;
    const token = localStorage.getItem('unlockToken') || '';

    // Free limit enforcement client-side: 1 file and watermark must remain
    if (!token && files.length > 1) {
      alert('Free version: 1 image at a time. Unlock to resize multiple images.');
      return;
    }

    statusEl.textContent = 'Processing...';
    const form = new FormData();
    files.forEach(f => form.append('files', f));
    form.append('w', preset.w);
    form.append('h', preset.h);
    form.append('fmt', preset.fmt);
    form.append('q', preset.q);
    form.append('keepAspect', keep ? '1' : '0');
    // Watermark parameter removed; images are never watermarked
    if (token) form.append('token', token);
    const res = await fetch('/process', { method: 'POST', body: form });
    if (!res.ok) {
      statusEl.textContent = 'Error processing images.';
      return;
    }
    const blob = await res.blob();
    // Build a temporary anchor to trigger the file download. Chrome
    // and some other browsers require that the element be appended to
    // the document for the click event to properly fire. After the
    // download is initiated, remove it again to keep the DOM clean.
    const a = document.createElement('a');
    const contentType = res.headers.get('Content-Type');
    const isZip = contentType && contentType.includes('zip');
    a.href = URL.createObjectURL(blob);
    a.download = isZip ? `resized_${Date.now()}.zip` : `resized.${preset.fmt}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    statusEl.textContent = 'Done.';
  };

  buyBtn.onclick = () => {
    // Redirect to the provided Stripe Payment Link to unlock pro features
    window.location.href = 'https://buy.stripe.com/test_cNi00bbCe5e1dKBdeh5os00';
  };

  // Initialize preset cards click handlers. When a card is clicked, it
  // updates the hidden select value, toggles the selected class, and
  // triggers the change event so custom size inputs show/hide as needed.
  document.querySelectorAll('.preset-card').forEach(card => {
    card.addEventListener('click', () => {
      // Remove selection from all cards
      document.querySelectorAll('.preset-card').forEach(c => c.classList.remove('selected'));
      // Add selection to the clicked card
      card.classList.add('selected');
      const val = card.getAttribute('data-value');
      presetSelect.value = val;
      // Trigger change on the select to update custom inputs
      presetSelect.dispatchEvent(new Event('change'));
      // Update the marketplace info box if this card corresponds to a marketplace preset
      try {
        const infoEl = document.getElementById('marketPresetInfo');
        if (infoEl && val) {
          const parsed = JSON.parse(val);
          if (parsed && parsed.w && parsed.h) {
            const w = parsed.w;
            const h = parsed.h;
            const gcd = (a,b) => b === 0 ? a : gcd(b, a % b);
            const g = gcd(w, h);
            const aspect = (w / g) + ':' + (h / g);
            infoEl.textContent = `${w} √ó ${h} (aspect ${aspect})`;
          }
        }
      } catch (e) {
        // ignore parse errors from non-JSON data-value entries
      }
    });
  });


      // Update quality percentage label when the range slider changes
      if (customQ && qualityValue) {
        customQ.addEventListener('input', () => {
          qualityValue.textContent = customQ.value + '%';
        });
      }

  /* Watermark removal handling removed */
  </script>

    <!-- Navigation interactivity and Pro integration -->
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const menuItems = document.getElementById('menuItems');
        const hamburger = document.getElementById('hamburger');
        if (hamburger && menuItems) {
          hamburger.addEventListener('click', () => {
            menuItems.classList.toggle('open');
          });
        }
        // Highlight active nav item based on current path
        const path = window.location.pathname.replace(/\/$/, '');
        const navResizer = document.getElementById('navResizer');
        const navPdf = document.getElementById('navPdf');
        const navBg = document.getElementById('navBg');
        if (path === '' || path === '/index.html' || path === '/') {
          navResizer && navResizer.classList.add('active');
        } else if (path.startsWith('/pdf')) {
          navPdf && navPdf.classList.add('active');
        } else if (path.startsWith('/background')) {
          navBg && navBg.classList.add('active');
        }
        // Pro button navigation
        const navProBtn = document.getElementById('navProBtn');
        if (navProBtn) {
          navProBtn.addEventListener('click', () => {
            window.location.href = 'https://buy.stripe.com/test_cNi00bbCe5e1dKBdeh5os00';
          });
        }
        // Hide old buy button if present
        const oldBtn = document.getElementById('buyBtn');
        if (oldBtn) {
          oldBtn.style.display = 'none';
        }
        // Pro state check: hide navProBtn if already unlocked
        fetch('/me', { credentials: 'include' }).then(res => res.json()).then(j => {
          if (j && j.pro && navProBtn) {
            navProBtn.style.display = 'none';
          }
        }).catch(() => {});
      });
    </script>
  <!-- Blog link footer -->
  <footer style="margin-top:48px;text-align:center;">
    <a href="/blog" id="footerBlogLink">Blog</a>
  </footer>

  <!-- Crop modal overlay. Hidden by default and toggled by JS -->
  <div id="cropModal">
    <div class="modal-content">
      <h3 style="margin-bottom:8px;font-size:1.25rem;font-weight:bold;">Crop Image</h3>
      <div id="cropPreviewArea" style="position:relative;width:100%;height:60vh;overflow:hidden;">
        <img id="cropImage" src="" alt="Image to crop" style="max-width:100%;max-height:100%;display:block;">
      </div>
      <!-- Controls for aspect ratio, width/height, zoom -->
      <div id="cropControls">
        <label>Aspect Ratio
          <select id="cropAspect">
            <option value="free">Freeform</option>
            <option value="1:1">1:1</option>
            <option value="4:3">4:3</option>
            <option value="3:2">3:2</option>
            <option value="16:9">16:9</option>
            <option value="9:16">9:16</option>
            <option value="5:4">5:4</option>
          </select>
        </label>
        <label>Width (px)
          <input type="number" id="cropWidth" min="1" value="0">
        </label>
        <label>Height (px)
          <input type="number" id="cropHeight" min="1" value="0">
        </label>
        <button type="button" id="zoomOutBtn" style="padding:4px 8px;border:1px solid var(--card-border);border-radius:6px;background:#f5f5ff;">-</button>
        <span id="zoomPercent" style="min-width:40px;text-align:center;">100%</span>
        <button type="button" id="zoomInBtn" style="padding:4px 8px;border:1px solid var(--card-border);border-radius:6px;background:#f5f5ff;">+</button>
        <button type="button" id="rotateLeftBtn" style="padding:4px 8px;border:1px solid var(--card-border);border-radius:6px;background:#f5f5ff;">‚ü≤</button>
        <button type="button" id="rotateRightBtn" style="padding:4px 8px;border:1px solid var(--card-border);border-radius:6px;background:#f5f5ff;">‚ü≥</button>
        <button type="button" id="flipHBtn" style="padding:4px 8px;border:1px solid var(--card-border);border-radius:6px;background:#f5f5ff;">‚áã</button>
        <button type="button" id="flipVBtn" style="padding:4px 8px;border:1px solid var(--card-border);border-radius:6px;background:#f5f5ff;">‚áÖ</button>
      </div>
      <div id="cropActions">
        <button id="cropConfirmBtn" type="button">Apply Crop</button>
        <button id="cropResetBtn" type="button">Reset</button>
        <button id="cropCancelBtn" type="button">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Load social presets and dynamic preset rendering -->
  <script src="/presets.js"></script>
  <!-- Cropping functionality using custom cropper implementation -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const cropModal = document.getElementById('cropModal');
      const cropImgEl = document.getElementById('cropImage');
      const cropBtnEl = document.getElementById('cropBtn');
      const cropAspect = document.getElementById('cropAspect');
      const cropWidthInput = document.getElementById('cropWidth');
      const cropHeightInput = document.getElementById('cropHeight');
      const zoomOutBtn = document.getElementById('zoomOutBtn');
      const zoomInBtn = document.getElementById('zoomInBtn');
      const rotateLeftBtn = document.getElementById('rotateLeftBtn');
      const rotateRightBtn = document.getElementById('rotateRightBtn');
      const flipHBtn = document.getElementById('flipHBtn');
      const flipVBtn = document.getElementById('flipVBtn');
      const cropConfirm = document.getElementById('cropConfirmBtn');
      const cropReset = document.getElementById('cropResetBtn');
      const cropCancel = document.getElementById('cropCancelBtn');
      const previewArea = document.getElementById('cropPreviewArea');
      // Remove any existing overlay from previous sessions
      // Create dynamic elements for custom cropper
      const dimT = document.createElement('div');
      const dimB = document.createElement('div');
      const dimL = document.createElement('div');
      const dimR = document.createElement('div');
      dimT.className = dimB.className = dimL.className = dimR.className = 'dim-overlay';
      previewArea.appendChild(dimT);
      previewArea.appendChild(dimB);
      previewArea.appendChild(dimL);
      previewArea.appendChild(dimR);
      const cropBox = document.createElement('div');
      cropBox.className = 'crop-box';
      // Add handles
      const positions = ['nw','n','ne','e','se','s','sw','w'];
      positions.forEach(pos => {
        const h = document.createElement('div');
        h.className = 'crop-handle ' + pos;
        cropBox.appendChild(h);
      });
      previewArea.appendChild(cropBox);
      // Rule of thirds lines inside crop box
      const ruleLines = [];
      for (let i = 1; i <= 2; i++) {
        const lh = document.createElement('div');
        lh.className = 'rule-line rule-h';
        cropBox.appendChild(lh);
        ruleLines.push(lh);
        const lv = document.createElement('div');
        lv.className = 'rule-line rule-v';
        cropBox.appendChild(lv);
        ruleLines.push(lv);
      }
      let naturalWidth = 0;
      let naturalHeight = 0;
      let scale = 1;
      let rotation = 0;
      let flipX = 1;
      let flipY = 1;
      let aspectRatio = null; // null for free
      let cropRect = { x: 50, y: 50, width: 200, height: 200 };
      let dragging = false;
      let resizing = false;
      let dragStart = { x: 0, y: 0 };
      let resizeStart = { x: 0, y: 0, w: 0, h: 0, cx: 0, cy: 0 };
      let activeHandle = '';
      function updateDimOverlays() {
        // dims overlay dims
        const { x, y, width, height } = cropRect;
        const pw = previewArea.clientWidth;
        const ph = previewArea.clientHeight;
        dimT.style.top = '0px';
        dimT.style.left = '0px';
        dimT.style.width = pw + 'px';
        dimT.style.height = y + 'px';
        dimB.style.top = (y + height) + 'px';
        dimB.style.left = '0px';
        dimB.style.width = pw + 'px';
        dimB.style.height = (ph - y - height) + 'px';
        dimL.style.top = y + 'px';
        dimL.style.left = '0px';
        dimL.style.width = x + 'px';
        dimL.style.height = height + 'px';
        dimR.style.top = y + 'px';
        dimR.style.left = (x + width) + 'px';
        dimR.style.width = (pw - x - width) + 'px';
        dimR.style.height = height + 'px';
      }
      function updateCropBox() {
        cropBox.style.left = cropRect.x + 'px';
        cropBox.style.top = cropRect.y + 'px';
        cropBox.style.width = cropRect.width + 'px';
        cropBox.style.height = cropRect.height + 'px';
        // update rule lines (2 vertical, 2 horizontal)
        const rh = cropRect.height / 3;
        const rw = cropRect.width / 3;
        // First two are horizontal
        ruleLines[0].style.top = rh + 'px';
        ruleLines[0].style.left = '0px';
        ruleLines[0].style.width = '100%';
        ruleLines[0].style.height = '1px';
        ruleLines[1].style.top = (2 * rh) + 'px';
        ruleLines[1].style.left = '0px';
        ruleLines[1].style.width = '100%';
        ruleLines[1].style.height = '1px';
        // Next two are vertical
        ruleLines[2].style.left = rw + 'px';
        ruleLines[2].style.top = '0px';
        ruleLines[2].style.width = '1px';
        ruleLines[2].style.height = '100%';
        ruleLines[3].style.left = (2 * rw) + 'px';
        ruleLines[3].style.top = '0px';
        ruleLines[3].style.width = '1px';
        ruleLines[3].style.height = '100%';
        updateDimOverlays();
        updateInputsFromCrop();
      }
      function updateInputsFromCrop() {
        // update width/height inputs in pixels of natural image
        if (!cropImgEl || !naturalWidth) return;
        const displayW = cropImgEl.clientWidth * scale;
        const displayH = cropImgEl.clientHeight * scale;
        const ratioX = naturalWidth / displayW;
        const ratioY = naturalHeight / displayH;
        const w = Math.round(cropRect.width * ratioX);
        const h = Math.round(cropRect.height * ratioY);
        cropWidthInput.value = w;
        cropHeightInput.value = h;
      }
      // Handle dragging/resizing
      function pointerDown(e) {
        e.preventDefault();
        const target = e.target;
        const rect = previewArea.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const py = e.clientY - rect.top;
        if (target.classList.contains('crop-handle')) {
          resizing = true;
          dragging = false;
          activeHandle = positions.find(pos => target.classList.contains(pos));
          resizeStart = { x: px, y: py, w: cropRect.width, h: cropRect.height, cx: cropRect.x, cy: cropRect.y };
        } else if (target === cropBox || target.parentElement === cropBox) {
          dragging = true;
          resizing = false;
          dragStart = { x: px, y: py, cx: cropRect.x, cy: cropRect.y };
        }
        document.addEventListener('pointermove', pointerMove);
        document.addEventListener('pointerup', pointerUp);
      }
      function pointerMove(e) {
        e.preventDefault();
        const rect = previewArea.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const py = e.clientY - rect.top;
        const pw = previewArea.clientWidth;
        const ph = previewArea.clientHeight;
        if (dragging) {
          const dx = px - dragStart.x;
          const dy = py - dragStart.y;
          cropRect.x = Math.min(Math.max(0, dragStart.cx + dx), pw - cropRect.width);
          cropRect.y = Math.min(Math.max(0, dragStart.cy + dy), ph - cropRect.height);
          updateCropBox();
        } else if (resizing) {
          let newW = resizeStart.w;
          let newH = resizeStart.h;
          let newX = resizeStart.cx;
          let newY = resizeStart.cy;
          const dx = px - resizeStart.x;
          const dy = py - resizeStart.y;
          function applyAspect(w, h) {
            if (aspectRatio) {
              if (Math.abs(w) > Math.abs(h * aspectRatio)) {
                h = w / aspectRatio;
              } else {
                w = h * aspectRatio;
              }
            }
            return { w, h };
          }
          if (activeHandle.includes('e')) {
            newW = resizeStart.w + dx;
          }
          if (activeHandle.includes('s')) {
            newH = resizeStart.h + dy;
          }
          if (activeHandle.includes('w')) {
            newW = resizeStart.w - dx;
            newX = resizeStart.cx + dx;
          }
          if (activeHandle.includes('n')) {
            newH = resizeStart.h - dy;
            newY = resizeStart.cy + dy;
          }
          // Apply aspect ratio
          if (aspectRatio) {
            const ratioVals = applyAspect(newW, newH);
            newW = ratioVals.w;
            newH = ratioVals.h;
            if (activeHandle.includes('w')) {
              newX = resizeStart.cx + (resizeStart.w - newW);
            }
            if (activeHandle.includes('n')) {
              newY = resizeStart.cy + (resizeStart.h - newH);
            }
          }
          // Constrain to minimum size
          const minSize = 20;
          newW = Math.max(minSize, newW);
          newH = Math.max(minSize, newH);
          // Constrain within bounds
          if (newX < 0) {
            newW += newX;
            newX = 0;
          }
          if (newY < 0) {
            newH += newY;
            newY = 0;
          }
          if (newX + newW > pw) {
            newW = pw - newX;
          }
          if (newY + newH > ph) {
            newH = ph - newY;
          }
          cropRect.x = newX;
          cropRect.y = newY;
          cropRect.width = newW;
          cropRect.height = newH;
          updateCropBox();
        }
      }
      function pointerUp() {
        dragging = false;
        resizing = false;
        document.removeEventListener('pointermove', pointerMove);
        document.removeEventListener('pointerup', pointerUp);
      }
      cropBox.addEventListener('pointerdown', pointerDown);
      // Also listen on preview area to allow dragging crop box edges
      // Zoom controls - simply adjust scale for preview image
      function applyTransform() {
        let transform = '';
        transform += `scale(${scale})`;
        transform += ` rotate(${rotation}deg)`;
        transform += ` scaleX(${flipX})`;
        transform += ` scaleY(${flipY})`;
        cropImgEl.style.transform = transform;
      }
      if (zoomInBtn) zoomInBtn.addEventListener('click', () => {
        scale = Math.min(5, scale + 0.1);
        applyTransform();
      });
      if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => {
        scale = Math.max(0.1, scale - 0.1);
        applyTransform();
      });
      if (rotateLeftBtn) rotateLeftBtn.addEventListener('click', () => {
        rotation = (rotation - 90) % 360;
        applyTransform();
      });
      if (rotateRightBtn) rotateRightBtn.addEventListener('click', () => {
        rotation = (rotation + 90) % 360;
        applyTransform();
      });
      if (flipHBtn) flipHBtn.addEventListener('click', () => {
        flipX = -flipX;
        applyTransform();
      });
      if (flipVBtn) flipVBtn.addEventListener('click', () => {
        flipY = -flipY;
        applyTransform();
      });
      function setAspectFromSelect() {
        const val = cropAspect.value;
        if (val === 'free') {
          aspectRatio = null;
        } else {
          const parts = val.split(':');
          const w = parseFloat(parts[0]);
          const h = parseFloat(parts[1]);
          if (w && h) aspectRatio = w / h;
        }
        // Update crop box dimensions to fit new aspect ratio
        const current = { ...cropRect };
        if (aspectRatio) {
          // Adjust width/height while keeping center
          let newW = current.width;
          let newH = newW / aspectRatio;
          if (newH > previewArea.clientHeight) {
            newH = previewArea.clientHeight;
            newW = newH * aspectRatio;
          }
          const cx = current.x + current.width / 2;
          const cy = current.y + current.height / 2;
          cropRect.width = newW;
          cropRect.height = newH;
          cropRect.x = Math.min(Math.max(0, cx - newW / 2), previewArea.clientWidth - newW);
          cropRect.y = Math.min(Math.max(0, cy - newH / 2), previewArea.clientHeight - newH);
        }
        updateCropBox();
      }
      cropAspect.addEventListener('change', setAspectFromSelect);
      // When width/height inputs change manually
      function inputsChanged() {
        const wVal = parseInt(cropWidthInput.value, 10);
        const hVal = parseInt(cropHeightInput.value, 10);
        if (isNaN(wVal) || isNaN(hVal) || !naturalWidth) return;
        const displayW = cropImgEl.clientWidth * scale;
        const displayH = cropImgEl.clientHeight * scale;
        const ratioX = displayW / naturalWidth;
        const ratioY = displayH / naturalHeight;
        const newW = wVal * ratioX;
        const newH = hVal * ratioY;
        // Keep center
        const cx = cropRect.x + cropRect.width / 2;
        const cy = cropRect.y + cropRect.height / 2;
        cropRect.width = newW;
        cropRect.height = newH;
        cropRect.x = Math.min(Math.max(0, cx - newW / 2), previewArea.clientWidth - newW);
        cropRect.y = Math.min(Math.max(0, cy - newH / 2), previewArea.clientHeight - newH);
        updateCropBox();
      }
      cropWidthInput.addEventListener('change', inputsChanged);
      cropHeightInput.addEventListener('change', inputsChanged);
      // Open cropping modal when crop button clicked
      if (cropBtnEl) {
        cropBtnEl.addEventListener('click', () => {
          if (!files || files.length !== 1) {
            alert('Please upload a single image to crop.');
            return;
          }
          const file = files[0];
          const reader = new FileReader();
          reader.onload = () => {
            cropImgEl.onload = () => {
              naturalWidth = cropImgEl.naturalWidth;
              naturalHeight = cropImgEl.naturalHeight;
              scale = 1;
              rotation = 0;
              flipX = 1;
              flipY = 1;
              applyTransform();
              // Initialize crop box to 80% of shorter side
              const pw = previewArea.clientWidth;
              const ph = previewArea.clientHeight;
              const side = Math.min(pw, ph) * 0.8;
              cropRect.width = side;
              cropRect.height = aspectRatio ? side / aspectRatio : side;
              cropRect.x = (pw - cropRect.width) / 2;
              cropRect.y = (ph - cropRect.height) / 2;
              updateCropBox();
              // Show modal and prevent body scrolling so the page underneath doesn‚Äôt scroll
              cropModal.classList.add('open');
              document.body.style.overflow = 'hidden';
              // Ensure viewport is at top to reveal the preview area
              window.scrollTo(0, 0);
            };
            cropImgEl.src = reader.result;
          };
          reader.readAsDataURL(file);
        });
      }
      // Reset crop
      if (cropReset) cropReset.addEventListener('click', () => {
        const pw = previewArea.clientWidth;
        const ph = previewArea.clientHeight;
        const side = Math.min(pw, ph) * 0.8;
        cropRect.width = side;
        cropRect.height = aspectRatio ? side / aspectRatio : side;
        cropRect.x = (pw - cropRect.width) / 2;
        cropRect.y = (ph - cropRect.height) / 2;
        scale = 1;
        rotation = 0;
        flipX = 1;
        flipY = 1;
        applyTransform();
        updateCropBox();
      });
      // Cancel
      if (cropCancel) cropCancel.addEventListener('click', () => {
        // Hide modal and restore page scrolling
        cropModal.classList.remove('open');
        document.body.style.overflow = '';
      });
      // Apply crop
      if (cropConfirm) cropConfirm.addEventListener('click', () => {
        if (!naturalWidth) return;
        // Create canvas with natural size of cropped area
        const displayW = cropImgEl.clientWidth * scale;
        const displayH = cropImgEl.clientHeight * scale;
        const ratioX = naturalWidth / displayW;
        const ratioY = naturalHeight / displayH;
        const natX = cropRect.x * ratioX;
        const natY = cropRect.y * ratioY;
        const natW = cropRect.width * ratioX;
        const natH = cropRect.height * ratioY;
        const canvas = document.createElement('canvas');
        canvas.width = natW;
        canvas.height = natH;
        const ctx = canvas.getContext('2d');
        ctx.save();
        // Apply flips and rotation relative to center
        ctx.translate(natW / 2, natH / 2);
        ctx.scale(flipX, flipY);
        ctx.rotate((rotation * Math.PI) / 180);
        ctx.drawImage(cropImgEl, -natX - natW / 2, -natY - natH / 2, naturalWidth, naturalHeight);
        ctx.restore();
        canvas.toBlob(blob => {
          if (blob) {
            const file = files[0];
            const parts = file.name.split('.');
            const ext = parts.length > 1 ? parts.pop() : 'jpg';
            const baseName = parts.join('.') || 'cropped';
            const newFileName = `${baseName}_cropped.${ext}`;
            const newFile = new File([blob], newFileName, { type: file.type });
            files = [newFile];
            renderList();
          }
          // Hide modal and restore page scrolling after applying crop
          cropModal.classList.remove('open');
          document.body.style.overflow = '';
        }, files[0].type || 'image/jpeg');
      });
    });
  </script>
</body>
</html>